library(knitr)
knitr::opts_chunk$set(fig.crop = F,echo=T,
warning=F, cache=F,
message=F, sanitize = T)
library(rwebppl)
library(dplyr)
library(tidyr)
library(ggplot2)
library(coda)
library(jsonlite)
rm(list=ls())
# # to get the maximum a posteriori value [MAP] (from samples)
# estimate_mode <- function(s) {
#   d <- density(s)
#   return(d$x[which.max(d$y)])
# }
# # upper bound of 95% credible interval
# hdi_upper<- function(s){
#   m <- HPDinterval(mcmc(s))
#   return(m["var1","upper"])
# }
# # lower bound of 95% credible interval
# hdi_lower<- function(s){
#   m <- HPDinterval(mcmc(s))
#   return(m["var1","lower"])
# }
towModel <- '
// unpack data from R
var lazinessPrior = datafromR["lazinessPrior"][0]
var lazyPulling = datafromR["lazyPulling"][0]
var matchInfo = datafromR["matchInfo"][0]
var tugOfWarModel = function(){
var strength = mem(function(person) {
return gaussian(50, 10)
})
var lazy = mem(function(person, match) {
return flip(lazinessPrior)
})
var pulling = function(person, match) {
return lazy(person, match) ? strength(person) * 0.5 : strength(person)
}
var totalPulling = function(team, match) {
return sum(map(function(person) {
return pulling(person, match)
}, team))
}
var winner = function(team1, team2, match) {
return totalPulling(team1, match) > totalPulling(team2, match) ? team1 : team2
}
var beat = function(team1,team2, match){
return winner(team1,team2, match) == team1
}
var conditions = function(i, len) {
if (i < len) {
if (matchInfo.games[i].winner == 1) {
condition(beat(matchInfo.games[i].team1,
matchInfo.games[i].team2,
i + 1));
} else if (matchInfo.games[i].winner == 2) {
condition(beat(matchInfo.games[i].team2,
matchInfo.games[i].team1,
i + 1));
}
conditions(i + 1, len);
}
}
conditions(0, matchInfo.games.length);
'
scenarioID = 0
shouldPlot = TRUE
#runModel <- function(scenarioID, shouldPlot) {
jsonFile = "stim.json"
stim <- fromJSON("stim.json")
scene = stim$scenarios[(scenarioID+1),]
retObject = 'return { '
for (i in 1:length(scene$questions[[1]])) {
elementToAdd = ""
if (scene$questions[[1]][i] == 0) {
elementToAdd = paste0("'strength", scene$subjects[[1]][i, 1], "': strength(", scene$subjects[[1]][i, 1], ")")
} else if (scene$questions[[1]][i] == 1) {
elementToAdd = paste0("'laziness", scene$subjects[[1]][i, 1], scene$subjects[[1]][i, 2], "': lazy(", scene$subjects[[1]][i, 1], ", ", scene$subjects[[1]][i, 2], ")")
} else if (scene$questions[[1]][i] == 2) {
elementToAdd = paste0("'beat", scene$subjects[[1]][i, 1], scene$subjects[[1]][i, 2], "': beat(", scene$subjects[[1]][i, 1], ", ", scene$subjects[[1]][i, 2], ")")
}
if (i < length(scene$questions[[1]])) {
elementToAdd = paste0(elementToAdd, ", ")
}
retObject = paste0(retObject, elementToAdd)
}
retObject = paste0(retObject, "}}")
towModel = paste0(towModel, retObject)
dataToWebPPL = list(lazinessPrior = 0.3,
lazyPulling = 0.5,
matchInfo = scene)
rs <- webppl(program_code = towModel,
model_var = "tugOfWarModel",
inference_opts = list(method = 'rejection', samples = 1000),
data = dataToWebPPL,
data_var = "datafromR",
output_format = "samples"
)
# Plotting the results
rs.tidy <- rs %>%
gather(key, val)
rs.tidy$val <- as.double(rs.tidy$val)
if (shouldPlot) {
for (i in names(rs)) {
print(mean(rs[[i]]))
}
ggplot(rs.tidy, aes( x = val ))+
geom_histogram() +
facet_wrap(~key, scales = 'free')
} else {
#return(mean(rs$strength1))
}
#}
df <- data.frame(strength=integer())
#You can run the model on just one scenario in stim by calling runModel(id, TRUE)
#runModel(30, TRUE)
#getMeans(21:30)
scenarioID = 0
shouldPlot = TRUE
#runModel <- function(scenarioID, shouldPlot) {
jsonFile = "exp2_stim.json"
stim <- fromJSON("stim.json")
scene = stim$scenarios[(scenarioID+1),]
retObject = 'return { '
for (i in 1:length(scene$questions[[1]])) {
elementToAdd = ""
if (scene$questions[[1]][i] == 0) {
elementToAdd = paste0("'strength", scene$subjects[[1]][i, 1], "': strength(", scene$subjects[[1]][i, 1], ")")
} else if (scene$questions[[1]][i] == 1) {
elementToAdd = paste0("'laziness", scene$subjects[[1]][i, 1], scene$subjects[[1]][i, 2], "': lazy(", scene$subjects[[1]][i, 1], ", ", scene$subjects[[1]][i, 2], ")")
} else if (scene$questions[[1]][i] == 2) {
elementToAdd = paste0("'beat", scene$subjects[[1]][i, 1], scene$subjects[[1]][i, 2], "': beat(", scene$subjects[[1]][i, 1], ", ", scene$subjects[[1]][i, 2], ")")
}
if (i < length(scene$questions[[1]])) {
elementToAdd = paste0(elementToAdd, ", ")
}
retObject = paste0(retObject, elementToAdd)
}
retObject = paste0(retObject, "}}")
towModel = paste0(towModel, retObject)
dataToWebPPL = list(lazinessPrior = 0.3,
lazyPulling = 0.5,
matchInfo = scene)
rs <- webppl(program_code = towModel,
model_var = "tugOfWarModel",
inference_opts = list(method = 'rejection', samples = 1000),
data = dataToWebPPL,
data_var = "datafromR",
output_format = "samples"
)
# Plotting the results
rs.tidy <- rs %>%
gather(key, val)
towModel
towModel <- '
// unpack data from R
var lazinessPrior = datafromR["lazinessPrior"][0]
var lazyPulling = datafromR["lazyPulling"][0]
var matchInfo = datafromR["matchInfo"][0]
var tugOfWarModel = function(){
var strength = mem(function(person) {
return gaussian(50, 10)
})
var lazy = mem(function(person, match) {
return flip(lazinessPrior)
})
var pulling = function(person, match) {
return lazy(person, match) ? strength(person) * 0.5 : strength(person)
}
var totalPulling = function(team, match) {
return sum(map(function(person) {
return pulling(person, match)
}, team))
}
var winner = function(team1, team2, match) {
return totalPulling(team1, match) > totalPulling(team2, match) ? team1 : team2
}
var beat = function(team1,team2, match){
return winner(team1,team2, match) == team1
}
var conditions = function(i, len) {
if (i < len) {
if (matchInfo.games[i].winner == 1) {
condition(beat(matchInfo.games[i].team1,
matchInfo.games[i].team2,
i + 1));
} else if (matchInfo.games[i].winner == 2) {
condition(beat(matchInfo.games[i].team2,
matchInfo.games[i].team1,
i + 1));
}
conditions(i + 1, len);
}
}
conditions(0, matchInfo.games.length);
'
scenarioID = 0
shouldPlot = TRUE
#runModel <- function(scenarioID, shouldPlot) {
jsonFile = "exp2_stim.json"
stim <- fromJSON("stim.json")
scene = stim$scenarios[(scenarioID+1),]
retObject = 'return { '
for (i in 1:length(scene$questions[[1]])) {
elementToAdd = ""
if (scene$questions[[1]][i] == 0) {
elementToAdd = paste0("'strength", scene$subjects[[1]][i, 1], "': strength(", scene$subjects[[1]][i, 1], ")")
} else if (scene$questions[[1]][i] == 1) {
elementToAdd = paste0("'laziness", scene$subjects[[1]][i, 1], scene$subjects[[1]][i, 2], "': lazy(", scene$subjects[[1]][i, 1], ", ", scene$subjects[[1]][i, 2], ")")
} else if (scene$questions[[1]][i] == 2) {
elementToAdd = paste0("'beat", scene$subjects[[1]][i, 1], scene$subjects[[1]][i, 2], "': beat(", scene$subjects[[1]][i, 1], ", ", scene$subjects[[1]][i, 2], ")")
}
if (i < length(scene$questions[[1]])) {
elementToAdd = paste0(elementToAdd, ", ")
}
retObject = paste0(retObject, elementToAdd)
}
retObject = paste0(retObject, "}}")
newModel = paste0(towModel, retObject)
dataToWebPPL = list(lazinessPrior = 0.3,
lazyPulling = 0.5,
matchInfo = scene)
rs <- webppl(program_code = newModel,
model_var = "tugOfWarModel",
inference_opts = list(method = 'rejection', samples = 1000),
data = dataToWebPPL,
data_var = "datafromR",
output_format = "samples"
)
# Plotting the results
rs.tidy <- rs %>%
gather(key, val)
rs.tidy$val <- as.double(rs.tidy$val)
if (shouldPlot) {
for (i in names(rs)) {
print(mean(rs[[i]]))
}
ggplot(rs.tidy, aes( x = val ))+
geom_histogram() +
facet_wrap(~key, scales = 'free')
} else {
#return(mean(rs$strength1))
}
#}
df <- data.frame(strength=integer())
#You can run the model on just one scenario in stim by calling runModel(id, TRUE)
#runModel(30, TRUE)
#getMeans(21:30)
scenarioID = 0
shouldPlot = TRUE
#runModel <- function(scenarioID, shouldPlot) {
stim <- fromJSON("exp2_stim.json")
scene = stim$scenarios[(scenarioID+1),]
retObject = 'return { '
for (i in 1:length(scene$questions[[1]])) {
elementToAdd = ""
if (scene$questions[[1]][i] == 0) {
elementToAdd = paste0("'strength", scene$subjects[[1]][i, 1], "': strength(", scene$subjects[[1]][i, 1], ")")
} else if (scene$questions[[1]][i] == 1) {
elementToAdd = paste0("'laziness", scene$subjects[[1]][i, 1], scene$subjects[[1]][i, 2], "': lazy(", scene$subjects[[1]][i, 1], ", ", scene$subjects[[1]][i, 2], ")")
} else if (scene$questions[[1]][i] == 2) {
elementToAdd = paste0("'beat", scene$subjects[[1]][i, 1], scene$subjects[[1]][i, 2], "': beat(", scene$subjects[[1]][i, 1], ", ", scene$subjects[[1]][i, 2], ")")
}
if (i < length(scene$questions[[1]])) {
elementToAdd = paste0(elementToAdd, ", ")
}
retObject = paste0(retObject, elementToAdd)
}
retObject = paste0(retObject, "}}")
newModel = paste0(towModel, retObject)
dataToWebPPL = list(lazinessPrior = 0.3,
lazyPulling = 0.5,
matchInfo = scene)
rs <- webppl(program_code = newModel,
model_var = "tugOfWarModel",
inference_opts = list(method = 'rejection', samples = 1000),
data = dataToWebPPL,
data_var = "datafromR",
output_format = "samples"
)
newModel
scenarioID = 0
shouldPlot = TRUE
#runModel <- function(scenarioID, shouldPlot) {
stim <- fromJSON("exp2_stim.json")
scene = stim$scenarios[(scenarioID+1),]
retObject = 'return { '
for (i in 1:length(scene$questions[[1]])) {
elementToAdd = ""
if (scene$questions[[1]][i] == 0) {
elementToAdd = paste0("'strength", scene$subjects[[1]][i, 1], "': strength(", scene$subjects[[1]][i, 1], ")")
} else if (scene$questions[[1]][i] == 1) {
elementToAdd = paste0("'laziness", scene$subjects[[1]][i, 1], scene$subjects[[1]][i, 2], "': lazy(", scene$subjects[[1]][i, 1], ", ", scene$subjects[[1]][i, 2], ")")
} else if (scene$questions[[1]][i] == 2) {
elementToAdd = paste0("'beat", scene$subjects[[1]][i, 1], scene$subjects[[1]][i, 2], "': beat(", scene$subjects[[1]][i, 1], ", ", scene$subjects[[1]][i, 2], ", 1000)")
}
if (i < length(scene$questions[[1]])) {
elementToAdd = paste0(elementToAdd, ", ")
}
retObject = paste0(retObject, elementToAdd)
}
retObject = paste0(retObject, "}}")
newModel = paste0(towModel, retObject)
dataToWebPPL = list(lazinessPrior = 0.3,
lazyPulling = 0.5,
matchInfo = scene)
rs <- webppl(program_code = newModel,
model_var = "tugOfWarModel",
inference_opts = list(method = 'rejection', samples = 1000),
data = dataToWebPPL,
data_var = "datafromR",
output_format = "samples"
)
newModel
library(knitr)
knitr::opts_chunk$set(fig.crop = F,echo=T,
warning=F, cache=F,
message=F, sanitize = T)
library(rwebppl)
library(dplyr)
library(tidyr)
library(ggplot2)
library(coda)
library(jsonlite)
rm(list=ls())
# # to get the maximum a posteriori value [MAP] (from samples)
# estimate_mode <- function(s) {
#   d <- density(s)
#   return(d$x[which.max(d$y)])
# }
# # upper bound of 95% credible interval
# hdi_upper<- function(s){
#   m <- HPDinterval(mcmc(s))
#   return(m["var1","upper"])
# }
# # lower bound of 95% credible interval
# hdi_lower<- function(s){
#   m <- HPDinterval(mcmc(s))
#   return(m["var1","lower"])
# }
towModel <- '
// unpack data from R
var lazinessPrior = datafromR["lazinessPrior"][0]
var lazyPulling = datafromR["lazyPulling"][0]
var matchInfo = datafromR["matchInfo"][0]
var tugOfWarModel = function(){
var strength = mem(function(person) {
return gaussian(50, 10)
})
var lazy = mem(function(person, match) {
return flip(lazinessPrior)
})
var pulling = function(person, match) {
return lazy(person, match) ? strength(person) * 0.5 : strength(person)
}
var totalPulling = function(team, match) {
return sum(map(function(person) {
return pulling(person, match)
}, team))
}
var winner = function(team1, team2, match) {
return totalPulling(team1, match) > totalPulling(team2, match) ? team1 : team2
}
var beat = function(team1,team2, match){
return winner(team1,team2, match) == team1
}
var conditions = function(i, len) {
if (i < len) {
if (matchInfo.games[i].winner == 1) {
condition(beat(matchInfo.games[i].team1,
matchInfo.games[i].team2,
i + 1));
} else if (matchInfo.games[i].winner == 2) {
condition(beat(matchInfo.games[i].team2,
matchInfo.games[i].team1,
i + 1));
}
conditions(i + 1, len);
}
}
conditions(0, matchInfo.games.length);
'
library(knitr)
knitr::opts_chunk$set(fig.crop = F,echo=T,
warning=F, cache=F,
message=F, sanitize = T)
library(rwebppl)
library(dplyr)
library(tidyr)
library(ggplot2)
library(coda)
library(jsonlite)
rm(list=ls())
# # to get the maximum a posteriori value [MAP] (from samples)
# estimate_mode <- function(s) {
#   d <- density(s)
#   return(d$x[which.max(d$y)])
# }
# # upper bound of 95% credible interval
# hdi_upper<- function(s){
#   m <- HPDinterval(mcmc(s))
#   return(m["var1","upper"])
# }
# # lower bound of 95% credible interval
# hdi_lower<- function(s){
#   m <- HPDinterval(mcmc(s))
#   return(m["var1","lower"])
# }
towModel <- '
// unpack data from R
var lazinessPrior = datafromR["lazinessPrior"][0]
var lazyPulling = datafromR["lazyPulling"][0]
var matchInfo = datafromR["matchInfo"][0]
var tugOfWarModel = function(){
var strength = mem(function(person) {
return gaussian(50, 10)
})
var lazy = mem(function(person, match) {
return flip(lazinessPrior)
})
var lazyRandom = function() {
return flip(lazinessPrior)
}
var pulling = function(person, match) {
return lazy(person, match) ? strength(person) * 0.5 : strength(person)
}
var totalPulling = function(team, match) {
return sum(map(function(person) {
return pulling(person, match)
}, team))
}
var winner = function(team1, team2, match) {
return totalPulling(team1, match) > totalPulling(team2, match) ? team1 : team2
}
var beat = function(team1,team2, match){
return winner(team1,team2, match) == team1
}
var wouldBeat = function(player1, player2) {
var p1 = lazyRandom() ? strength(player1) * 0.5 : strength(player1)
var p2 = lazyRandom() ? strength(player2) * 0.5 : strength(player2)
return p1 > p2
}
var conditions = function(i, len) {
if (i < len) {
if (matchInfo.games[i].winner == 1) {
condition(beat(matchInfo.games[i].team1,
matchInfo.games[i].team2,
i + 1));
} else if (matchInfo.games[i].winner == 2) {
condition(beat(matchInfo.games[i].team2,
matchInfo.games[i].team1,
i + 1));
}
conditions(i + 1, len);
}
}
conditions(0, matchInfo.games.length);
'
scenarioID = 0
shouldPlot = TRUE
#runModel <- function(scenarioID, shouldPlot) {
stim <- fromJSON("exp2_stim.json")
scene = stim$scenarios[(scenarioID+1),]
retObject = 'return { '
for (i in 1:length(scene$questions[[1]])) {
elementToAdd = ""
if (scene$questions[[1]][i] == 0) {
elementToAdd = paste0("'strength", scene$subjects[[1]][i, 1], "': strength(", scene$subjects[[1]][i, 1], ")")
} else if (scene$questions[[1]][i] == 1) {
elementToAdd = paste0("'laziness", scene$subjects[[1]][i, 1], scene$subjects[[1]][i, 2], "': lazy(", scene$subjects[[1]][i, 1], ", ", scene$subjects[[1]][i, 2], ")")
} else if (scene$questions[[1]][i] == 2) {
elementToAdd = paste0("'beat", scene$subjects[[1]][i, 1], scene$subjects[[1]][i, 2], "': wouldBeat(", scene$subjects[[1]][i, 1], ", ", scene$subjects[[1]][i, 2], ", 100)")
}
if (i < length(scene$questions[[1]])) {
elementToAdd = paste0(elementToAdd, ", ")
}
retObject = paste0(retObject, elementToAdd)
}
retObject = paste0(retObject, "}}")
newModel = paste0(towModel, retObject)
dataToWebPPL = list(lazinessPrior = 0.3,
lazyPulling = 0.5,
matchInfo = scene)
rs <- webppl(program_code = newModel,
model_var = "tugOfWarModel",
inference_opts = list(method = 'rejection', samples = 1000),
data = dataToWebPPL,
data_var = "datafromR",
output_format = "samples"
)
# Plotting the results
rs.tidy <- rs %>%
gather(key, val)
rs.tidy$val <- as.double(rs.tidy$val)
if (shouldPlot) {
for (i in names(rs)) {
print(mean(rs[[i]]))
}
ggplot(rs.tidy, aes( x = val ))+
geom_histogram() +
facet_wrap(~key, scales = 'free')
} else {
#return(mean(rs$strength1))
}
#}
df <- data.frame(strength=integer())
#You can run the model on just one scenario in stim by calling runModel(id, TRUE)
#runModel(30, TRUE)
#getMeans(21:30)
